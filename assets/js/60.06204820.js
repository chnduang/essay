(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{352:function(e,t,n){"use strict";n.r(t);var a=n(4),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"开发中经常遇到的javascript问题整理-超实用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发中经常遇到的javascript问题整理-超实用"}},[e._v("#")]),e._v(" 开发中经常遇到的JavaScript问题整理(超实用)")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/u2mM-GvWObd6JI4I9oWg2w",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/u2mM-GvWObd6JI4I9oWg2w"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"获取一个月有多少天"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取一个月有多少天"}},[e._v("#")]),e._v(" 获取一个月有多少天")]),e._v(" "),t("p",[e._v("今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据")]),e._v(" "),t("p",[t("code",[e._v("new Date(year, month, date, hrs, min, sec)")]),e._v("，"),t("code",[e._v("new Date")]),e._v(" 可以接受这些参数创建一个时间对象 其中当我们把 "),t("code",[e._v("date")]),e._v(" 设置为 "),t("code",[e._v("0")]),e._v(" 的时候，可以直接通过 "),t("code",[e._v("getDate()")]),e._v(" 获取到最后一天的日期然后得到我们要的最后一天")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Date(2019, 12, 0).getDate(); // 31\nnew Date(2018, 2, 0).getDate(); // 28\n// 根据这个我们可以得到一个方法\nfunction getMonthLength(month) {\n  const date = new Date(month);\n  const year = date.getFullYear();\n  // 月份是从 0 开始计算的\n  const _month = date.getMonth() + 1;\n  return new Date(year, _month, 0).getDate();\n}\n")])])]),t("h2",{attrs:{id:"关于函数的-length-属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于函数的-length-属性"}},[e._v("#")]),e._v(" 关于函数的 length 属性")]),e._v(" "),t("p",[e._v("360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(() => 1).length === 0; // 输出什么\n")])])]),t("p",[e._v("我所理解的拥有 "),t("code",[e._v("length")]),e._v(" 的对象一般都是数组或者类数组对象，或者定义了 "),t("code",[e._v("length")]),e._v(" 属性的对象，所以我回答说这个应该是 "),t("code",[e._v("false")]),e._v(" 吧，后来面试告诉我函数是有 "),t("code",[e._v("length")]),e._v(" 属性的，函数的 "),t("code",[e._v("length")]),e._v(" 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 "),t("code",[e._v("arguments")]),e._v("，而 "),t("code",[e._v("arguments")]),e._v(" 也是一个类数组对象所以他是有 "),t("code",[e._v("length")]),e._v(" 属性的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// so\n(() => 1).length === 0; // 输出 true\n(a => a).length; // 输出 1\n")])])]),t("h2",{attrs:{id:"数组中字符串键值的处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组中字符串键值的处理"}},[e._v("#")]),e._v(" 数组中字符串键值的处理")]),e._v(" "),t("p",[e._v("在 JavaScript 中数组是通过数字进行索引，但是有趣的是他们也是对象，所以也可以包含 "),t("code",[e._v("字符串")]),e._v(" 键值和属性，但是这些不会被计算在数组的长度（length）内")]),e._v(" "),t("p",[e._v("如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当做数字索引来处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const arr = [];\narr[0] = 1;\narr['1'] = '嘿嘿';\narr['cym'] = 'cym';\nconsole.log(arr); // [1, '嘿嘿', cym: 'cym']\nconsole.log(arr.length); // 2\n")])])]),t("h2",{attrs:{id:"void-运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#void-运算符"}},[e._v("#")]),e._v(" void 运算符")]),e._v(" "),t("p",[t("code",[e._v("undefined")]),e._v(" 是一个内置标志符，它的值为 "),t("code",[e._v("undefined")]),e._v("（除非被重新定义过），通过 "),t("code",[e._v("void")]),e._v(" 运算符即可得到该值")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("void")]),e._v(" 之后的语句或表达式都将返回 "),t("code",[e._v("undefined")]),e._v("。"),t("code",[e._v("void")]),e._v(" 并不会改变表达式的结果，只是让表达式不返回值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("void true; // undefined\nvoid 0; // undefined\n")])])]),t("p",[t("code",[e._v("void")]),e._v(" 运算符在其他地方也可以派上用场，比如不让表达式返回任何结果。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 该函数不需要有任何返回结果\nfunction doSomething(sign) {\n  if (!sign) {\n    return void setTimeout(doSomething, 100);\n  }\n}\n// 或许你经常向下面一样这么写\nfunction doSomething(sign) {\n  if (!sign) {\n    setTimeout(doSomething, 100);\n    return;\n  }\n}\n")])])]),t("h2",{attrs:{id:"关于-json-stringify"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于-json-stringify"}},[e._v("#")]),e._v(" 关于 JSON.stringify")]),e._v(" "),t("p",[t("code",[e._v("JSON.stringify")]),e._v(" 和 "),t("code",[e._v("toString()")]),e._v(" 效果基本相同，只不过序列化的结果总是字符串")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('JSON.stringify(42); // "42"\nJSON.stringify(\'42\'); // ""42""（含有双引号的字符串）\nJSON.stringify(null); // "null"\nJSON.stringify(true); // "true"\n')])])]),t("h3",{attrs:{id:"不安全的-json-值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不安全的-json-值"}},[e._v("#")]),e._v(" 不安全的 JSON 值")]),e._v(" "),t("p",[e._v("所有安全的 "),t("code",[e._v("JSON")]),e._v(" 值都可以使用 "),t("code",[e._v("JSON.stringify")]),e._v(" 序列化，不安全的 "),t("code",[e._v("JSON")]),e._v(" 值有："),t("code",[e._v("undefined")]),e._v("、"),t("code",[e._v("function")]),e._v("、"),t("code",[e._v("symbol")]),e._v(" 和 "),t("code",[e._v("循环引用")]),e._v("。"),t("code",[e._v("JSON.stringify")])]),e._v(" "),t("p",[e._v("在对象中遇到这些不安全的 "),t("code",[e._v("JSON")]),e._v(" 值的时候会自动将其忽略，在数组中遇到则会返回 "),t("code",[e._v("null")]),e._v("，以保证数组成员位置不变")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('JSON.stringify(undefined); // null\nJSON.stringify(function () {}); // null\nJSON.stringify([1, undefined, 2, function () {}, 3]); // "1, null, 2, null, 3"\nJSON.stringify({ a: 2, b: function () {} }); // "{"a":2}"\n')])])]),t("h3",{attrs:{id:"tojson-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tojson-方法"}},[e._v("#")]),e._v(" toJSON 方法")]),e._v(" "),t("p",[e._v("如果对象中定义了 "),t("code",[e._v("toJSON")]),e._v(" 方法，那么在 "),t("code",[e._v("JSON")]),e._v(" 序列化的时候优先调用该方法，主要是为了处理循环引用的时候，我们让其返回一个合理的值")]),e._v(" "),t("p",[e._v("也就是说 "),t("code",[e._v("toJSON")]),e._v(" 方法应该返回一个能够被字符串安全化的 "),t("code",[e._v("JSON")]),e._v(" 值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const o = {\n  a: 'cym',\n  toJSON() {\n    return { c: 'b' };\n  },\n};\n\nJSON.stringify(o); // {\"c\":\"b\"}\n")])])]),t("h3",{attrs:{id:"json-stringify-的第二个参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify-的第二个参数"}},[e._v("#")]),e._v(" JSON.stringify 的第二个参数")]),e._v(" "),t("p",[e._v("我们可以向 "),t("code",[e._v("JSON.stringify")]),e._v(" 中传递一个可选参数 "),t("code",[e._v("replacer")]),e._v("，他可以书数组也可以书函数，用来指定对象序列化的时候哪些属性应该被处理，哪些应该被排除，和 "),t("code",[e._v("toJSON")]),e._v(" 很像")]),e._v(" "),t("ol",[t("li",[e._v("当 "),t("code",[e._v("replacer")]),e._v(" 是一个数组时，那么他必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外的属性就会被忽略")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const obj = {\n  a: 42,\n  b: 30,\n  c: 100,\n};\nJSON.stringify(obj, ['a', 'c']); // {\"a\":42,\"c\":100}\n")])])]),t("ol",[t("li",[e._v("当 "),t("code",[e._v("replacer")]),e._v(" 是一个函数时，他会对对象本身调用一次，然后在对对象中的每个属性各调用一次。每次传递两个参数（对象的键和值）。如果要忽略某个键就返回 "),t("code",[e._v("undecided")]),e._v("，否则就返回指定的值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const obj = {\n  a: 42,\n  b: 30,\n  c: 100,\n};\nJSON.stringify(obj, (k, v) => {\n  // 注意：第一次 k 是 undefined，v 是原对象\n  if (k !== \'c\') return v;\n}); // "{"a":42,"b":30}"\n')])])]),t("h2",{attrs:{id:"一元运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一元运算符"}},[e._v("#")]),e._v(" 一元运算符")]),e._v(" "),t("p",[e._v("我们都知道一个字符串转换为数字，可以使用 "),t("code",[e._v('+ "12"')]),e._v(" 转换为数字 12，也可以使用 "),t("code",[e._v("-")]),e._v("，这样的 "),t("code",[e._v("+、-")]),e._v(" 是一元运算符，这样将数字转换为字符串的方法属于显示转换")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("-` 运算符还有反转符号位的功能，当然不能把一元操作符连在一起写，不然会变成 `--`，当做递减运算符号来计算了，我们可以理解为 `-` 运算符出在单数次数会转符号位，出现双次数会抵消反转，比如说 `1 - - 1 === 2\n# 这是 js 代码哦，不是 python\n1 + - + - + - 1   # 0\n1 - - 1           # 2\n1 - - - 1         # 0\n")])])]),t("h2",{attrs:{id:"字位反转操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字位反转操作符"}},[e._v("#")]),e._v(" 字位反转操作符 ~")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("~` 返回 2 的补码，`~x` 大致等同于 `-(x+1)\n~42; // -(42+1) ===> -43\n")])])]),t("p",[e._v("在 "),t("code",[e._v("-(x+1)")]),e._v(" 中唯一能够得到 0（或者严格来说时候 -0）的 x 值是 -1，也就是说 ~ 和一些数字在一起会返回一个假值 0，其他情况下则返回真值")]),e._v(" "),t("p",[e._v("-1 是一个 "),t("code",[e._v("哨位值")]),e._v("，哨位值是那些在各个类型中被赋予了特殊含义的值。在 C 语言中 -1 代表函数执行失败，大于等于 0 的值代表函数执行成功")]),e._v(" "),t("p",[e._v("比如在 JavaScript 中字符串的 indexOf 方法也遵循这一惯例，该方法在字符串中搜索指定的字符串，如果找到就返回该子字符串所在的位置，否则返回 -1")]),e._v(" "),t("h3",{attrs:{id:"的用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#的用途"}},[e._v("#")]),e._v(" ~ 的用途")]),e._v(" "),t("p",[e._v("我们知道在 JavaScript 中假值有："),t("code",[e._v("undefined、null、false、+0、-0、NaN、''")]),e._v("，其他都为真值，所以负数也是真值，那么我们就可以拿着 "),t("code",[e._v("~")]),e._v(" 和 "),t("code",[e._v("indexOf")]),e._v(" 一起检结果强制类型转换为 真/假 值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const str = 'hello world';\n~str.indexOf('lo'); // -4，真值\nif (~str.indexOf('lo')) {\n  // true\n  // 找到匹配\n}\n~str.indexOf('ol'); // 0，假值\n!~str.indexOf('ol'); // true\nif (!~str.indexOf('ol')) {\n  // true\n  // 没有找到匹配\n}\n")])])]),t("p",[e._v("~ 要比 "),t("code",[e._v(">=0")]),e._v(" 和 "),t("code",[e._v("== -1")]),e._v(" 更简洁")]),e._v(" "),t("h3",{attrs:{id:"字位截除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字位截除"}},[e._v("#")]),e._v(" 字位截除")]),e._v(" "),t("p",[e._v("我们经常使用 "),t("code",[e._v("~~")]),e._v(" 来截取数字值的小数部分，以为这是和 Math.floor 效果是一样的，实际上并非如此")]),e._v(" "),t("p",[t("code",[e._v("~~")]),e._v(" 中第一个 ~ 执行 ToInt32 并反转字位，然后第二个在进行一次字位反转，就是将所有的字位反转回原值，最后得到的结果仍是 ToInt32 的结果")]),e._v(" "),t("p",[t("code",[e._v("~~")]),e._v(" 只适用于 32 位的数字，更重要的是他对负数的处理与 Math.floor 不同，所以使用时要多加注意")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Math.floor(1.9); // 1\n~~1.9; // 1\n// 操作负数\nMath.floor(-1.9); // -2\n~~-1.9; // -1\n~~x` 能将值截除为一个 32 位的整数，`x | 0` 也可以，而且看起来更简洁哦，不过出于对运算符优先级的考虑，我们更倾向于使用 `~~x\n~~1.9; // 1\n1.9 | 0; // 1\n\n~~-1.9; // -1\n-1.9 | 0; // -1\n")])])]),t("h2",{attrs:{id:"给定一组-url-实现并发请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给定一组-url-实现并发请求"}},[e._v("#")]),e._v(" 给定一组 url 实现并发请求")]),e._v(" "),t("p",[e._v("原题是这样的：给定一组 url，利用 js 的异步实现并发请求，并按顺序输出结果")]),e._v(" "),t("h3",{attrs:{id:"promise-all"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all")]),e._v(" "),t("p",[e._v("首先我们可以想到的是利用 "),t("code",[e._v("Promise.all")]),e._v(" 来实现，代码实现如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const urls = ['./1.json', './2.json', './3.json'];\nfunction getData(url) {\n  // 返回一个 Promise 利用 Promise.all 接受\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'json';\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          resolve(xhr.response);\n        }\n      }\n    };\n    xhr.open('GET', url, true);\n    xhr.send(null);\n  });\n}\nfunction getMultiData(urls) {\n  // Promise.all 接受一个包含 promise 的数组，如果不是 promise 数组会被转成 promise\n  Promise.all(urls.map(url => getData(url))).then(results => {\n    console.log(results);\n  });\n}\n")])])]),t("h3",{attrs:{id:"不用-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不用-promise"}},[e._v("#")]),e._v(" 不用 Promise")]),e._v(" "),t("p",[e._v("原题是不用 "),t("code",[e._v("Promise")]),e._v(" 来实现，我们可以写一个方法，加个回调函数，等数据全部回来之后，触发回调函数传入得到的数据，那么数据全部回来的就是我们要考虑的核心问题，我们可以用个数组或者对象，然后判断一下数组的 length 和传入的 url 的长度是否一样来做判断")]),e._v(" "),t("h4",{attrs:{id:"使用对象做映射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用对象做映射"}},[e._v("#")]),e._v(" 使用对象做映射")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const urls = ['./1.json', './2.json', './3.json'];\nfunction getAllDate(urls, cd) {\n  const result = {};\n  function getData(url, idx) {\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'json';\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          result[idx] = xhr.response;\n          // 如果两者 length 相等说明都请求完成了\n          if (Object.keys(result).length === urls.length) {\n            // 给对象添加length属性，方便转换数组\n            result.length = urls.length;\n            cd && cd(Array.from(result));\n          }\n        }\n      }\n    };\n  }\n  // 触发函数执行\n  urls.forEach((url, idx) => getData(url, idx));\n}\n// 使用\ngetAllDate(urls, data => {\n  console.log(data);\n});\n")])])]),t("h4",{attrs:{id:"使用数组实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用数组实现"}},[e._v("#")]),e._v(" 使用数组实现")]),e._v(" "),t("p",[e._v("和上面的基本思路差不多，不过这次换成了数组，也可以给个信号量来做判断")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getGroupData(urls, cb) {\n  const results = [];\n  let count = 0;\n  const getData = url => {\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'json';\n    xhr.onreadystatechange = _ => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          results.push(xhr.response);\n          if (++count === urls.length) {\n            cb && cb(results);\n          }\n        }\n      }\n    };\n    xhr.open('GET', url, true);\n    xhr.send(null);\n  };\n  urls.forEach(url => getData(url));\n}\n\ngetGroupData(urls, data => {\n  console.log(data);\n});\n")])])]),t("h2",{attrs:{id:"类型转换问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型转换问题"}},[e._v("#")]),e._v(" 类型转换问题")]),e._v(" "),t("p",[e._v("原题：如何让 (a == 1 && a == 2 && a == 3) 的值为 true?")]),e._v(" "),t("p",[e._v("这个问题考查的数据类型转换，"),t("code",[e._v("==")]),e._v(" 类型转换有个基本规则")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("NaN")]),e._v(" 与任何值都不相等，包括自己本身")]),e._v(" "),t("li",[t("code",[e._v("undefined")]),e._v(" 与 "),t("code",[e._v("null")]),e._v(" 相等(==)，其他都不等")]),e._v(" "),t("li",[e._v("对象与字符串类型做比较，会把对象转换成字符串然后做比较")]),e._v(" "),t("li",[e._v("其他类型比较都要转换成 "),t("code",[e._v("数字")]),e._v(" 做比较")])]),e._v(" "),t("p",[e._v("那么这个问题我们重写 "),t("code",[e._v("toString")]),e._v(" 或者 "),t("code",[e._v("valueOf")]),e._v(" 方法就可以了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const a = {\n  val: 1,\n  toString() {\n    return this.val++;\n  },\n};\nif (a == 1 && a == 2 && a == 3) {\n  console.log('ok');\n}\n")])])]),t("p",[e._v("还有一种方法实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var i = 1;\nObject.defineProperty(window, 'a', {\n  get() {\n    return i++;\n  },\n});\n\nif (a == 1 && a == 2 && a == 3) {\n  console.log('OK');\n}\n")])])]),t("h3",{attrs:{id:"拓展一下-为什么是-true"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓展一下-为什么是-true"}},[e._v("#")]),e._v(" 拓展一下 [] == ![] 为什么是 true")]),e._v(" "),t("p",[e._v("上面隐式类型转换规则中提到，其他类型比较都要转换成数字做比较，这个就是对应那条规则的")]),e._v(" "),t("ul",[t("li",[e._v("首先 "),t("code",[e._v("[].toString()")]),e._v(" 会得到一个 "),t("code",[e._v("''")]),e._v(" 字符串")]),e._v(" "),t("li",[t("code",[e._v("![]")]),e._v(" 得到一个布尔值 "),t("code",[e._v("false")])]),e._v(" "),t("li",[t("code",[e._v("''")]),e._v(" 与 "),t("code",[e._v("false")]),e._v(" 比较肯定要转换成数字比较")]),e._v(" "),t("li",[e._v("那么 "),t("code",[e._v("''")]),e._v(" 转换则为 "),t("code",[e._v("0")]),e._v("， "),t("code",[e._v("false")]),e._v(" 转换也是 "),t("code",[e._v("0")])]),e._v(" "),t("li",[e._v("所以这道题就是 "),t("code",[e._v("true")])])]),e._v(" "),t("h2",{attrs:{id:"_1-tostring-的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-tostring-的问题"}},[e._v("#")]),e._v(" 1..toString 的问题")]),e._v(" "),t("p",[e._v("有时候我们看到别人的代码中会写到数字调其他类型的方法的时候会写成 "),t("code",[e._v("1..toString()")]),e._v("这样的写法")]),e._v(" "),t("p",[e._v("因为直接用整数型数字调方法就会报错，但是如果是一个浮点数的话就不会报错了")]),e._v(" "),t("p",[e._v("因为可能在 "),t("code",[e._v(".")]),e._v(" 上面存在争议，一个数字后面加点，解释器他不知道你这是小数还是要调取方法，所以就跑异常了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.toString()     // Uncaught SyntaxError: Invalid or unexpected token\n1..toString()    // '1'\n1.2.toString()   // '1.2'\n")])])]),t("h2",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),t("h3",{attrs:{id:"对象增加迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象增加迭代器"}},[e._v("#")]),e._v(" 对象增加迭代器")]),e._v(" "),t("p",[e._v("类数组对象的特征：必须有长度、索引、能够被迭代，否则这个对象不可以使用 "),t("code",[e._v("...")]),e._v(" 语法转数组，我们可以使用 Array.from 转，当然我们也可以给对象添加一个迭代器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const obj = {\n  0: 1,\n  1: 2,\n  2: 3,\n  3: 4,\n  length: 4,\n  [Symbol.iterator]() {\n    let idx = 0\n    return {\n      next() {\n        return {\n          value: obj[idx],\n          done: idx++ >= obj.length,\n        }\n      }\n    }\n  }\n}\n// 此时对象就被添加了迭代器\n[...obj]  // 1 2 3 4\nfor (const val of obj) {\n  console.log(val)  // 1 2 3 4\n}\n")])])]),t("p",[e._v("上面的问题可以字节使用生成器来实现，生成器返回一个迭代器，迭代器有 next 方法，调用 next 方法可以返回 value 和 done")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const obj = {\n  0: 1,\n  1: 2,\n  2: 3,\n  3: 4,\n  length: 4,\n  [Symbol.iterator]: function* () {\n    let idx = 0\n    while (idx !== this.length) {\n      yield this[idx++]\n    }\n  }\n")])])]),t("h3",{attrs:{id:"实现一个字符串的迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现一个字符串的迭代器"}},[e._v("#")]),e._v(" 实现一个字符串的迭代器")]),e._v(" "),t("p",[e._v("实现一个字符串的迭代器：传入一组字符串并返回单个字符的范例。一旦更新的字符串，输出也跟着替换掉旧的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function generator(str) {\n  let idx = 0;\n  return {\n    next() {\n      return {\n        value: str[idx],\n        done: idx++ >= str.length,\n      };\n    },\n  };\n}\n// 测试\nconst str = 'as';\nlet gen = generator(str);\nconsole.log(gen.next());\nconsole.log(gen.next());\nconsole.log(gen.next());\nconsole.log(gen.next());\ngen = generator('str');\nconsole.log(gen.next());\nconsole.log(gen.next());\nconsole.log(gen.next());\nconsole.log(gen.next());\n// { value: 'a', done: false }\n// { value: 's', done: false }\n// { value: undefined, done: true }\n// { value: undefined, done: true }\n// { value: 's', done: false }\n// { value: 't', done: false }\n// { value: 'r', done: false }\n// { value: undefined, done: true }\n")])])]),t("h3",{attrs:{id:"简单模拟-co"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单模拟-co"}},[e._v("#")]),e._v(" 简单模拟 co")]),e._v(" "),t("p",[e._v("模拟一下 co 的实现")]),e._v(" "),t("p",[e._v("首先来看一则例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst readFile = promisify(fs.readFile);\n\nfunction* read() {\n  const name = yield readFile(path.resolve(__dirname, 'name.txt'), 'utf8');\n  const age = yield readFile(path.resolve(__dirname, name), 'utf8');\n  return age;\n}\n\nconst it = read();\n\nlet { value, done } = it.next();\nvalue.then(data => {\n  let { value, done } = it.next(data);\n  // console.log(data, '???')\n  value.then(data => {\n    let { value, done } = it.next(data);\n    console.log(value);\n  });\n});\n")])])]),t("p",[e._v("使用 co 库可以很容易解决这个问题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const co = require('co');\n// co 接受一个生成器\nco(read()).then(data => {\n  console.log(data);\n});\n// 那模拟一下\nfunction _co(it) {\n  // 首先返回一个 promise\n  return new Promise((resolve, reject) => {\n    // 因为可以传值的原因，不可以直接使用循环实现，需要使用 递归\n    function next(data) {\n      const { value, done } = it.next(data);\n      if (done) return resolve(value);\n      // 保证值是一个 promise\n      Promise.resolve(value).then(data => {\n        next(data);\n      }, reject);\n    }\n    next();\n  });\n}\n")])])]),t("h2",{attrs:{id:"菲波那切数列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#菲波那切数列"}},[e._v("#")]),e._v(" 菲波那切数列")]),e._v(" "),t("ul",[t("li",[e._v("今天新东方的面试还提到了菲波那切数列，其实这个东西蛮很有趣，简单介绍一下")]),e._v(" "),t("li",[e._v("1、1、2、3、5、8、13、21、34 ....")]),e._v(" "),t("li",[e._v("这道题有个规律，第一项加上第二项永远等于第三项：1 + 1 = 2；1 + 2 = 3；2 + 3 = 5；3 + 5 = 8 ....")]),e._v(" "),t("li",[e._v("要求是传入第几项，得到该值，根据这个规律来实现一下")])]),e._v(" "),t("h3",{attrs:{id:"简单写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单写法"}},[e._v("#")]),e._v(" 简单写法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function fibonacci(n) {\n  // 第一项和第二项都返回1\n  if (n === 1 || n === 2) return 1;\n  // 我们只要返回 n - 1（n的前一项）与 n - 2（n的前两项）的和便是我们要的值\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n")])])]),t("h3",{attrs:{id:"优化版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化版本"}},[e._v("#")]),e._v(" 优化版本")]),e._v(" "),t("p",[e._v("上面的写法，求 20 次以内的总和运行会很快，50 次以上特别慢，100 次 以上可能就爆栈了，所以我们需要优化写法，缓存每次计算后的值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function feibo(n, sum1 = 1, sum2 = 1) {\n  if (n === 1 || n === 2) return sum2;\n  return feibo(n - 1, sum2, sum1 + sum2);\n}\n")])])]),t("p",[e._v("这种写法缓存了，每次计算后的值，执行效率会很高，100 次以上也会秒返回结果，这个也叫作尾递归优化")]),e._v(" "),t("h2",{attrs:{id:"观察者与发布订阅"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者与发布订阅"}},[e._v("#")]),e._v(" 观察者与发布订阅")]),e._v(" "),t("blockquote",[t("p",[e._v("一直以来，我以为发布订阅和观察者是一个思路，一次偶然的机会我发现他们是两种不同的设计思路")])]),e._v(" "),t("p",[e._v("虽然他们都是"),t("code",[e._v("实现了对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得倒通知，然后自动更新")]),e._v("。但是他们之间是有一定区别的。")]),e._v(" "),t("h3",{attrs:{id:"观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[e._v("#")]),e._v(" 观察者模式")]),e._v(" "),t("p",[e._v("观察者模式会有 "),t("code",[e._v("观察者")]),e._v(" 与 "),t("code",[e._v("被观察者(观察目标)")]),e._v(" 两个对象存在，观察者可以有多个，观察目标可以添加多个观察者，可以通知观察者。观察者模式是面向与目标和观察者编程的，耦合目标和观察者")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 被观察者\nclass Subject {\n  constructor() {\n    this.subs = [];\n  }\n  add(observer) {\n    this.subs.push(observer);\n  }\n  notify(...args) {\n    this.subs.forEach(ob => ob.update(...args));\n  }\n}\n// 观察者\nclass Observer {\n  update(...args) {\n    console.log('Observer -> update -> args', args);\n  }\n}\n\n// 使用\nconst o1 = new Observer();\nconst o2 = new Observer();\nconst o3 = new Observer();\nconst o5 = new Observer();\nconst sub = new Subject();\n// 添加观察者\nsub.add(o1);\nsub.add(o2);\nsub.add(o3);\n// 通知观察者\nsub.notify('嘿嘿嘿');\n")])])]),t("h3",{attrs:{id:"发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[e._v("#")]),e._v(" 发布订阅模式")]),e._v(" "),t("p",[e._v("发布订阅模式会有一个调度中心的概念。是面向调度中心编程的，对发布者与订阅者解耦")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class PubSub {\n  constructor() {\n    this.handlers = {};\n  }\n  subscribe(type, fn) {\n    if (!this.handlers[type]) {\n      this.handlers[type] = [];\n    }\n    this.handlers[type].push(fn);\n  }\n  publish(type, ...args) {\n    if (!this.handlers[type]) return;\n    this.handlers[type].forEach(fn => fn(...args));\n  }\n}\n\nconst ps = new PubSub();\n\nps.subscribe('a', console.log);\nps.subscribe('a', console.log);\nps.subscribe('a', console.log);\nps.subscribe('a', console.log);\nps.publish('a', 'hello world');\n")])])]),t("h2",{attrs:{id:"字符串转-txt-文件-blob"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串转-txt-文件-blob"}},[e._v("#")]),e._v(" 字符串转 txt 文件（blob）")]),e._v(" "),t("p",[e._v("有个要求：纯前端实现，不可以使用 "),t("code",[e._v("nodejs")])]),e._v(" "),t("p",[e._v("实现原理也很简单，就像我们平时下载一个本地文件一样，可以动态的创建一个可以下载的 "),t("code",[e._v("a")]),e._v(" 标签，给它设置 "),t("code",[e._v("download")]),e._v(" 属性，然后把下载的内容转 "),t("code",[e._v("blob")]),e._v(" 创建下载链接下载即可")]),e._v(" "),t("p",[e._v("具体实现如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function exportTxt(text, filename) {\n  const eleLink = document.createElement('a');\n  eleLink.download = filename;\n  eleLink.style.display = 'none';\n  // 将内容转为 blob\n  const blob = new Blob([text]);\n  eleLink.href = URL.createObjectURL(blob);\n  document.body.appendChild(eleLink);\n  eleLink.click();\n  document.body.removeChild(eleLink);\n}\n")])])]),t("h2",{attrs:{id:"奇偶数判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#奇偶数判断"}},[e._v("#")]),e._v(" 奇偶数判断")]),e._v(" "),t("p",[e._v("可能会遇到一个做奇偶数判断的方法吧，反正我遇到了，一句话搞定")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isEven = num => num % 2 === 0;\n")])])]),t("h2",{attrs:{id:"格式化金钱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#格式化金钱"}},[e._v("#")]),e._v(" 格式化金钱")]),e._v(" "),t("p",[e._v("项目中我们经常会遇到金钱格式化需求，或者说数字格式化一下，方便阅读（数字比较大的情况下）")]),e._v(" "),t("p",[e._v("比如说 "),t("code",[e._v("999999999")]),e._v("，直接阅读很不直观，格式化后 "),t("code",[e._v("999,999,999")])]),e._v(" "),t("p",[e._v("通常我们会使用正则来处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function formatPrice(price) {\n  return String(price).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n")])])]),t("p",[e._v("也可以不使用正则然后优雅的处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function formatPrice(price) {\n  return String(price)\n    .split('')\n    .reverse()\n    .reduce((prev, next, index) => {\n      return (index % 3 ? next : next + ',') + prev;\n    });\n}\n")])])]),t("p",[e._v("上面是两种提到的比较常用的方案，但是 js 还有个比较牛逼的 API 可以直接实现这个需求哦，它就是 "),t("code",[e._v("toLocaleString")]),e._v("，我们可以直接数字调用这个方法就可以实现，金额的格式化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(999999999).toLocaleString(); // 999,999,999\n// 当然还可以更秀一点\nconst options = {\n  style: 'currency',\n  currency: 'CNY',\n};\n(123456).toLocaleString('zh-CN', options); // ¥123,456.00\n")])])]),t("p",[t("code",[e._v("toLocaleString")]),e._v(" 可以接收两个可选参数："),t("code",[e._v("locales")]),e._v(" 和 "),t("code",[e._v("options")]),e._v("，而且这个 api 在各大浏览器通用不存在兼容问题并且这个 "),t("code",[e._v("api")]),e._v(" 不止存在 Number 的原型上，Array、Object、Date 原型上都有这个 api，并且格式化出来的值可以根据我们传入的参数出现各种结果")]),e._v(" "),t("p",[e._v("参数及用法可以参考 MDN")]),e._v(" "),t("h2",{attrs:{id:"深度冻结对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深度冻结对象"}},[e._v("#")]),e._v(" 深度冻结对象")]),e._v(" "),t("p",[e._v("在 vue 项目开发中，有些不变的常量，我们不想 vue 为他做双向绑定，以减少一些性能上消耗，我们可以把使用 "),t("code",[e._v("Object.freeze")]),e._v(" 将对象冻结，此时 vue 将不会对这个对象进行冻结，但是这个冻结只是冻结对象第一层，所以遇到对象层级比较深的话，我们可以写个深度冻结的 api，来对常量对象做一些冻结优化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const deepFreeze = o => {\n  const propNames = Object.getOwnPropertyNames(o);\n  propNames.forEach(name => {\n    const prop = o[name];\n    if (typeof prop === 'object' && prop !== null) {\n      deepFreeze(prop);\n    }\n  });\n  return Object.freeze(o);\n};\n")])])]),t("h2",{attrs:{id:"脱敏处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#脱敏处理"}},[e._v("#")]),e._v(" 脱敏处理")]),e._v(" "),t("p",[e._v("在一些涉及到用户隐私情况下，可能会遇到对用户的手机号身份证号之类的信息脱敏，但是这个脱敏数据的规则是根据用户信息要脱敏字段动态的生成的，此时我们动态拼接正则来实现一个动态脱敏规则")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const encryptReg = (before = 3, after = 4) => {\n  return new RegExp('(\\\\d{' + before + '})\\\\d*(\\\\d{' + after + '})');\n};\n// 使用：'13456789876'.replace(encryptReg(), '$1****$2') -> \"134****9876\"\n")])])]),t("h2",{attrs:{id:"树遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树遍历"}},[e._v("#")]),e._v(" 树遍历")]),e._v(" "),t("p",[e._v("对于树结构的遍历一般有深度优先和广度优先")]),e._v(" "),t("p",[e._v("广度优先和深度优先的概念很简单，区别如下：")]),e._v(" "),t("ul",[t("li",[e._v("深度优先，访问完一颗子树再去访问后面的子树，而访问子树的时候，先访问根再访问根的子树，称为先序遍历；先访问子树再访问根，称为后序遍历。")]),e._v(" "),t("li",[e._v("广度优先，即访问树结构的第 n+1 层前必须先访问完第 n 层")])]),e._v(" "),t("ol",[t("li",[e._v("深度优先")])]),e._v(" "),t("p",[e._v("先序遍历")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const treeForEach = (tree, func) => {\n  tree.forEach(data => {\n    func(data);\n    data.children && treeForEach(data.children, func);\n  });\n};\n")])])]),t("p",[e._v("后序遍历，只需要调换一下节点遍历和子树遍历的顺序即可")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const treeForEach = (tree, func) => {\n  tree.forEach(data => {\n    data.children && treeForEach(data.children, func);\n    func(data);\n  });\n};\n")])])]),t("ol",[t("li",[e._v("广度优先")])]),e._v(" "),t("p",[e._v("广度优先的思路是，维护一个队列，队列的初始值为树结构根节点组成的列表，重复执行以下步骤直到队列为空。取出队列中的第一个元素，进行访问相关操作，然后将其后代元素（如果有）全部追加到队列最后。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const treeForEach = (tree, func) => {\n  let node,\n    list = [...tree];\n  while ((node = list.shift())) {\n    func(node);\n    node.children && list.push(...node.children);\n  }\n};\n")])])]),t("h2",{attrs:{id:"数组分组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组分组"}},[e._v("#")]),e._v(" 数组分组")]),e._v(" "),t("p",[e._v("开发移动端的时候，遇到一个首页菜单改版的需求，首页菜单根据权限控制显隐，而菜单每页展示八个小菜单，超过八个做 swipe 滑动切换，当时项目用了 vant 做的 UI 框架，菜单那模块就选择了他的轮播插件，菜单做成了一个扁平化的 list 配置，首先根据权限过滤出所有有权限的菜单项，然后每八个一分组，处理成一个二维数据来遍历菜单")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const arrayGroupBySize = (arr, size = 2) => {\n  const result = [];\n  for (let i = 0, len = arr.length; i < len; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n};\n")])])]),t("h2",{attrs:{id:"下划线与驼峰"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#下划线与驼峰"}},[e._v("#")]),e._v(" 下划线与驼峰")]),e._v(" "),t("p",[e._v("做一些数据持久化的工作的时候经常会出现下划线命名和驼峰命名的转化，因为在前端处理中规范是驼峰命名，而像 mysql 之类的规范是下划线命名，所以在处理后返回给前端的数据需要转换为驼峰命名，而对数据库的读写需要下划线命名")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const toHump = name => {\n  return name.replace(/\\_(\\w)/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n};\n\nconst toLine = name => {\n  return name.replace(/([A-Z])/g, '_$1').toLowerCase();\n};\n")])])]),t("h2",{attrs:{id:"校验时间格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#校验时间格式"}},[e._v("#")]),e._v(" 校验时间格式")]),e._v(" "),t("p",[e._v("业务中遇到一个校验一下传入时间格式是否为一个时间格式，下面的方法可以完美校验")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isDate = str => {\n  return typeof str !== 'number' && str !== null && new Date(str) !== 'Invalid Date';\n};\n")])])]),t("h3",{attrs:{id:"字符串中的空格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串中的空格"}},[e._v("#")]),e._v(" 字符串中的空格")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("\\xa0  代替 "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v("nbsp"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("可以实现在字符串变量中添加空格\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);