(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{338:function(a,e,t){"use strict";t.r(e);var n=t(4),s=Object(n.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"javascript-函数式编程解析-上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-函数式编程解析-上"}},[a._v("#")]),a._v(" JavaScript 函数式编程解析（上）")]),a._v(" "),e("h2",{attrs:{id:"一些必要的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些必要的概念"}},[a._v("#")]),a._v(" 一些必要的概念")]),a._v(" "),e("ol",[e("li",[a._v("纯函数（Pure Function）")])]),a._v(" "),e("blockquote",[e("p",[a._v("Pure function 意指相同的输入，永远会得到相同的输出，而且没有任何显著的副作用。")])]),a._v(" "),e("blockquote",[e("p",[a._v("纯函数就是数学里的函数，这也是函数式编程的全部。")])]),a._v(" "),e("ol",[e("li",[a._v("副作用")])]),a._v(" "),e("blockquote",[e("p",[e("em",[a._v("副作用")]),a._v("是在计算结果的过程中，系统状态的一种改变，或是外部世界可观察的"),e("em",[a._v("交互作用")]),a._v("。")])]),a._v(" "),e("p",[a._v("副作用可以包含，但不限于：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("更改文件系统")])]),a._v(" "),e("li",[e("p",[a._v("在资料库写入纪录")])]),a._v(" "),e("li",[e("p",[a._v("发送一个 http 请求")])]),a._v(" "),e("li",[e("p",[a._v("状态变化")])]),a._v(" "),e("li",[e("p",[a._v("打印到屏幕/ log")])]),a._v(" "),e("li",[e("p",[a._v("DOM 查询")])]),a._v(" "),e("li",[e("p",[a._v("存取系统状态")])])]),a._v(" "),e("p",[a._v("概括来说，"),e("strong",[a._v("任何 function 与外部环境的交互都是副作用。")])]),a._v(" "),e("ol",[e("li",[a._v("柯里化（curry）")])]),a._v(" "),e("p",[a._v("使用更少的参数调用一个函数，返回一个接受剩余参数的函数。举例如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const add = x => y => x + y;\n\nconst increment = add(1);\n\nconst addTen = add(10);\n\nincrement(2); // 3\n\naddTen(2); // 12\n")])])]),e("h2",{attrs:{id:"函数式编程的优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程的优势"}},[a._v("#")]),a._v(" 函数式编程的优势")]),a._v(" "),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 确定性（可预测性、数据不可变），同样的输入必然得到相同的输出\n")])])])]),a._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 可以使用数学定律\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 结合律（associative）\n\nadd(add(x, y), z) === add(x, add(y, z));\n\n// 交换律（commutative）\n\nadd(x, y) === add(y, x);\n\n// 同一律（identity）\n\nadd(x, 0) === x;\n\n// 分配律（distributive）\n\nmultiply(x, add(y,z)) === add(multiply(x, y), multiply(x, z));\n")])])]),e("h2",{attrs:{id:"函数式编程的适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程的适用场景"}},[a._v("#")]),a._v(" 函数式编程的适用场景")]),a._v(" "),e("ul",[e("li",[a._v("可变状态（mutable state）")]),a._v(" "),e("li",[a._v("不受限的副作用（unrestricted side effects）")]),a._v(" "),e("li",[a._v("无原则设计（unprincipled design）")])]),a._v(" "),e("h2",{attrs:{id:"函数是一等公民的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数是一等公民的意义"}},[a._v("#")]),a._v(" 函数是一等公民的意义")]),a._v(" "),e("p",[a._v("在 JavaScript 中，函数是一等公民，它意味着函数就跟其他任何数据类型一样，并没有什么特殊之处——可以存储在数组中，作为函数的参数传递、赋值给变量，等等。作为“一等公民”，函数的意义至少有如下几点：")]),a._v(" "),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 有助于减少不必要的重构\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 如果renderPost功能发生变化，必须改变包装函数\n\nhttpGet('/post/2', json => renderPost(json));\n\n// 例如增加一个err\n\nhttpGet('/post/2', (json, err) => renderPost(json, err));\n\n\n// 如果我们把它写成一个一等公民函数，那么就不需要变了\n\nhttpGet('/post/2', renderPost);\n")])])]),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 有助于增加通用性和可重用性\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 专门为特定的功能准备\n\nconst validArticles = articles =>\n\n  articles.filter(article => article !== null && article !== undefined),\n\n// 看上去有无限的通用性和可重用性\n\nconst compact = xs => xs.filter(x => x !== null && x !== undefined);\n")])])]),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 不需要使用 this，但是需要注意适配外部API\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const fs = require('fs');\n\n// scary\n\nfs.readFile('freaky_friday.txt', Db.save);\n\n// less so\n\nfs.readFile('freaky_friday.txt', Db.save.bind(Db));\n")])])]),e("h3",{attrs:{id:"纯函数的价值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#纯函数的价值"}},[a._v("#")]),a._v(" 纯函数的价值")]),a._v(" "),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 可缓存\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const memoize = (f) => {\n\n  const cache = {};\n\n  return (...args) => {\n\n    const argStr = JSON.stringify(args);\n\n    cache[argStr] = cache[argStr] || f(...args);\n\n    return cache[argStr];\n\n  };\n\n};\n\n\nconst squareNumber = memoize(x => x * x);\n\nsquareNumber(4); // 16\n\nsquareNumber(4); // 16, 返回输入4的缓存结果\n")])])]),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" 可移植性/自文档化（Portable / Self-documenting）\n")])])])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// impure\nconst signUp = (attrs) => {\n  const user = saveUser(attrs);\n  welcomeUser(user);\n};\n\n// pure\nconst signUp = (Db, Email, attrs) => () => {\n  const user = saveUser(Db, attrs);\n  welcomeUser(Email, user);\n};\n")])])]),e("p",[a._v("纯函数把所有可能改变输出的变量"),e("code",[a._v("Db")]),a._v("和"),e("code",[a._v("Email")]),a._v("，都作为函数签名，这样我们就能知道函数是做什么的，依赖什么参数——提供了更多的信息。可移植性是 JS 的一个强大特性，函数会通过 socket 序列化并传输，意味着在 web worker 中我们可以运行所有代码。")]),a._v(" "),e("ol",[e("li",[a._v("可测试的（Testable）：利用特性，只需要给出输入和断言的输出即可。")]),a._v(" "),e("li",[a._v("可推理的（Reasonable）：同理")]),a._v(" "),e("li",[a._v("并行代码（Parallel Code）：由于不需要共享内存，所以可以并行处理纯函数")])]),a._v(" "),e("h2",{attrs:{id:"柯里化-currying"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#柯里化-currying"}},[a._v("#")]),a._v(" 柯里化（Currying）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// curry :: ((a, b, ...) -> c) -> a -> b -> ... -> c\nfunction curry(fn) {\n  const arity = fn.length;\n  return function $curry(...args) {\n    if (args.length < arity) {\n      return $curry.bind(null, ...args);\n    }\n\n    return fn.call(null, ...args);\n  };\n}\n\nconst match = curry((what, s) => s.match(what));\nconst replace = curry((what, replacement, s) => s.replace(what, replacement));\nconst filter = curry((f, xs) => xs.filter(f));\nconst map = curry((f, xs) => xs.map(f));\n")])])]),e("p",[a._v("通过以上的柯里化函数，我们可以把函数式编程变得简洁，没有冗余。尽管有多个参数，我们仍然可以保留数学函数的定义。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("match(/r/g, 'hello world'); // [ 'r' ]\n\nconst hasLetterR = match(/r/g); // x => x.match(/r/g)\nhasLetterR('hello world'); // [ 'r' ]\nhasLetterR('just j and s and t etc'); // null\nfilter(hasLetterR, ['rock and roll', 'smooth jazz']); // ['rock and roll']\n\nconst removeStringsWithoutRs = filter(hasLetterR); // xs => xs.filter(x => x.match(/r/g))\nremoveStringsWithoutRs(['rock and roll', 'smooth jazz', 'drum circle']); // ['rock and roll', 'drum circle']\nconst noVowels = replace(/[aeiou]/ig); // (r,x) => x.replace(/[aeiou]/ig, r)\nconst censored = noVowels('*'); // x => x.replace(/[aeiou]/ig, '*')\ncensored('Chocolate Rain'); // 'Ch*c*l*t* R**n'\n")])])]),e("h2",{attrs:{id:"组合-composing"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合-composing"}},[a._v("#")]),a._v(" 组合（Composing）")]),a._v(" "),e("p",[a._v("Composing 就是把函数像“管道”一样组合起来。下面展示最简单的组合示例。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const composes = (f, g) => x => f(g(x));\nconst toUpperCase = x => x.toUpperCase();\nconst exclaim = x => `${x}!`;\nconst shout = compose(exclaim, toUpperCase);\n\nshout('send in the clowns'); // \"SEND IN THE CLOWNS!\"\n")])])]),e("p",[a._v("以下是一个通用的 compose 函数：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const compose = (...fns) => (...args) => fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];\n")])])]),e("p",[a._v("因为 compose 也是纯函数，同样满足分配律：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 满足分配律\ncompose(f, compose(g, h)) === compose(compose(f, g), h);\n")])])]),e("p",[a._v("所以不管传参的顺序如何，它都返回相同的结果，非常强大 👍")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const arg = ['jumpkick', 'roundhouse', 'uppercut'];\nconst lastUpper = compose(toUpperCase, head, reverse);\nconst loudLastUpper = compose(exclaim, toUpperCase, head, reverse);\n\nlastUpper(arg); // 'UPPERCUT'\nloudLastUpper(arg); // 'UPPERCUT!'\n")])])]),e("h2",{attrs:{id:"pointfree-风格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pointfree-风格"}},[a._v("#")]),a._v(" Pointfree 风格")]),a._v(" "),e("p",[a._v("Pointfree 的意思是"),e("strong",[a._v("不使用所要操作的数据，只合成运算过程")]),a._v("。下面是使用"),e("strong",[a._v("Ramda")]),a._v("[1]函数库的"),e("code",[a._v("pipe")]),a._v("方法实现 Pointfree 的例子，选自阮一峰老师的**《Pointfree 编程风格指南》**[2]。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var str = 'Lorem ipsum dolor sit amet consectetur adipiscing elit';\n")])])]),e("p",[a._v("上面字符串最长的单词有多少个字符呢？先定义一些基本运算：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 以空格分割单词\nvar splitBySpace = s => s.split(' ');\n\n// 每个单词的长度\nvar getLength = w => w.length;\n\n// 词的数组转换成长度的数组\nvar getLengthArr = arr => R.map(getLength, arr);\n\n// 返回较大的数字\nvar getBiggerNumber = (a, b) => a > b ? a : b;\n\n// 返回最大的一个数字\nvar findBiggestNumber = arr => R.reduce(getBiggerNumber, 0, arr);\n")])])]),e("p",[a._v("然后把基本运算合成为一个函数：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var getLongestWordLength = R.pipe(\n\n  splitBySpace,\n\n  getLengthArr,\n\n  findBiggestNumber\n\n);\n\ngetLongestWordLength(str) // 11\n")])])]),e("p",[a._v("可以看到，整个运算由三个步骤构成，每个步骤都有语义化的名称，非常的清晰。这就是 Pointfree 风格的优势。Ramda 提供了很多现成的方法，可以直接使用这些方法，省得自己定义一些常用函数（查看"),e("strong",[a._v("完整代码")]),a._v("[3]）。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 上面代码的另一种写法\n\nvar getLongestWordLength = R.pipe(\n\n  R.split(' '),\n\n  R.map(R.length),\n\n  R.reduce(R.max, 0)\n\n);\n")])])]),e("p",[a._v("再看一个实战的例子，拷贝自 Scott Sauyet 的文章**《Favoring Curry》"),e("strong",[a._v("[4]。那篇文章能帮助你深入理解柯里化，强烈推荐阅读。下面是一段服务器返回的 JSON 数据。"),e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),a._v("现在要求是，找到用户 Scott 的所有未完成任务，并按到期日期升序排列。"),e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),a._v("过程式编程的代码如下（查看")]),a._v("完整代码**[5]）。"),e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),a._v("上面代码不易读，出错的可能性很大。现在使用 Pointfree 风格改写（查看"),e("strong",[a._v("完整代码")]),a._v("[6]）。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const getIncompleteTaskSummaries = (name) => {\n\n  return fetchData()\n\n          .then(R.prop('tasks'))\n\n          .then(R.filter(R.propEq('username', name)))\n\n          .then(R.reject(R.propEq('complete', true)))\n\n          .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n\n          .then(R.sortBy(R.prop('dueDate')))\n\n}\n")])])]),e("p",[a._v("上面代码就变得清晰很多了。")]),a._v(" "),e("h2",{attrs:{id:"常用-pointfree-纯函数的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用-pointfree-纯函数的实现"}},[a._v("#")]),a._v(" 常用 Pointfree 纯函数的实现")]),a._v(" "),e("p",[a._v("下面的实现仅仅为了基本演示，如果考虑实际开发，请参考"),e("strong",[a._v("ramda")]),a._v("[7],"),e("strong",[a._v("lodash")]),a._v("[8], 或"),e("strong",[a._v("folktale")]),a._v("[9]。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// curry :: ((a, b, ...) -> c) -> a -> b -> ... -> c\n\nfunction curry(fn) {\n\n  const arity = fn.length;\n\n  return function $curry(...args) {\n    if (args.length < arity) {\n      return $curry.bind(null, ...args);\n    }\n\n    return fn.call(null, ...args);\n\n  };\n\n}\n\n\n// compose :: ((y -> z), (x -> y),  ..., (a -> b)) -> a -> z\nconst compose = (...fns) => (...args) => fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];\n\n// forEach :: (a -> ()) -> [a] -> ()\nconst forEach = curry((fn, xs) => xs.forEach(fn));\n\n// map :: Functor f => (a -> b) -> f a -> f b\n\nconst map = curry((fn, f) => f.map(fn));\n\n// reduce :: (b -> a -> b) -> b -> [a] -> b\n\nconst reduce = curry((fn, zero, xs) => xs.reduce(fn, zero));\n\n// replace :: RegExp -> String -> String -> String\n\nconst replace = curry((re, rpl, str) => str.replace(re, rpl));\n\n// sortBy :: Ord b => (a -> b) -> [a] -> [a]\n\nconst sortBy = curry((fn, xs) => xs.sort((a, b) => {\n\n  if (fn(a) === fn(b)) {\n\n    return 0;\n\n  }\n\n  return fn(a) > fn(b) ? 1 : -1;\n\n}));\n\n\n// prop :: String -> Object -> a\n\nconst prop = curry((p, obj) => obj[p]);\n")])])]),e("p",[a._v("关于更多 Pointfree 纯函数的实现可以参考"),e("strong",[a._v("Pointfree Utilities")]),a._v("[10]。")])])}),[],!1,null,null,null);e.default=s.exports}}]);